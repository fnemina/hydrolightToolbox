import numpy as np
import xarray as xr
import pandas as pd

def read_h_lfile(path: str)->xr.Dataset:
    """ This functions reads a default lrootname in path file generated by Hydrolight and returns and xarray object.
        We only read the results as given by that file and not the input configuration."""
    
    # Check if we have a valid header by reading the first line
    with open(path) as dfile:
        s = next(dfile)
        if s.strip() != r"\begin_header":
            raise IOError(f"Invalid file {path}")
            
        # Read the title of the run from the second line and the skip to the end of the header
        title_run = next(dfile).strip()
    
    # use pandas to read the dataframe
    df = pd.read_csv(path, skiprows=16, sep="   ", index_col=[0,1,2,3], header=None)
    # rename columns and dices
    df.columns = ["total radiance", "L_sky", "L_w", "L_sr"]
    df.index.names = ["depth","theta","phi","wave"]
    # Convert to xarray
    s = xr.Dataset.from_dataframe(df)

    # Add units
    s["depth"].attrs["units"] = "m"
    s["theta"].attrs["units"] = "deg"
    s["phi"].attrs["units"] = "deg"
    s["wave"].attrs["units"] = "nm"
    s["total radiance"].attrs["units"] = "W/(m^2 sr nm)"
    s["L_sky"].attrs["units"] = "W/(m^2 sr nm)"
    s["L_w"].attrs["units"] = "W/(m^2 sr nm)"
    s["L_sr"].attrs["units"] = "W/(m^2 sr nm)"

    # Set run title
    s.attrs["title"] = title_run
    return s


def read_h_dfile(path: str)->xr.Dataset:
    """ This functions reads a default drootname in path file generated by Hydrolight and returns and xarray object.
        We only read the results as given by that file and not the input configuration."""
    with open(path) as dfile:

        # Check if we have a valid header by reading the first line
        s = next(dfile)
        if s.strip() != r"\begin_header":
            raise IOError(f"Invalid file {path}")
            
        # Read the title of the run from the second line and the skip to the end of the header
        title_run = next(dfile).strip()
        for s in dfile:
            if s.strip() == "\end_header":
                break
        next(dfile)
        
        # Read the coordinates from the grid data section
        structure_dict = {}
        for s in dfile:
            # Exit the grid data section
            if s.strip() == "End of grid data.  Beginning blocks of wavelength-dependent data":
                break
            # Create a new key
            if s[0] != " ":
                case = s.strip()
                structure_dict[case] = []
            # Store values in the current key
            elif s[0:3] == "   ":
                arr = np.fromstring(s, sep=" ")
                structure_dict[case] = np.append(structure_dict[case], arr)
            
        
        # Read the data values and structure them as [wave,(z, depth,phi, theta)] depending on which coordinates apply
        wl = []
        wl_dict = {}
        tmp_dict= {}
        for s in dfile:
            # Create a new wavelength
            if s[0:2] == " w":
                # If we have a current wavelength dictionary, we store it
                if len(wl) > 0:
                    wl_dict[current_wl] = tmp_dict
                current_wl = float(s.strip().split(" ")[-1])
                wl.append(current_wl)
                # Reset the current wavelength dictionary
                tmp_dict = {}
                
            # Create a new key
            if s[0] != " ":
                case = s.strip()
                tmp_dict[case] = []
            # Store values in the current key
            elif s[0:3] == "   ":
                arr = np.fromstring(s, sep=" ")
                tmp_dict[case] = np.append(tmp_dict[case], arr)
        # Save the last wavelength dictionary
        wl_dict[current_wl] = tmp_dict
        wl = np.array(wl)
        
        # Create a new dictionary to xarray formated data
        _tmp = {}
        # Units and coordinates for each array
        unitsc = {'theta':'deg', 'phi':'deg', 'zeta':"", 'z':'m', 
                 'zkfcn':'m', 'bndmu':"", 'bndphi':'deg', 'omega':'sr', 
                 'wave':'nm', 'waveb':'nm'}
        unitsv = {'acoef':"1/m", 'acoef1':"1/m", 'acoef2':"1/m", 
                  'acoef3':"1/m", 'acoef4':"1/m", 
                  'bcoef':"1/m", 'bcoef1':"1/m", 'bcoef2':"1/m", 
                  'bcoef3':"1/m", 'bcoef4':"1/m", 
                  'bbcoef':"1/m", 'bbcoef1':"1/m", 'bbcoef2':"1/m",
                  'bbcoef3':"1/m", 'bbcoef4':"1/m", 
                  'atten':"1/m", 'albedo':"", 'Eou':"W/(m^2 nm)", 
                  'Eod':"W/(m^2 nm)", 'Eu':"W/(m^2 nm)", 'Ed':"W/(m^2 nm)", 'mubar_u':("wave","depth"), 
                  'mubar_d':"", 'mubar':"", 'R':"", 
                  'Kd':"1/m", 'Ku':"1/m", 'Ko':"1/m", 
                  'Knet':"1/m", 'KLu':"1/m", 
                  'Rad_Ma':"W/(m^2 sr nm)", 'Rad_Mz':"W/(m^2 sr nm)", 
                  'Rad_Pa':"W/(m^2 sr nm)", 'Rad_Pz':"W/(m^2 sr nm)", 
                  'Rad_0Ma':"W/(m^2 sr nm)", 'Rad_0Pa':"W/(m^2 sr nm)", 
                  'Rad_0Pz':"W/(m^2 sr nm)",'Rad_0Pz':"W/(m^2 sr nm)", 
                  'Rad_sky':"W/(m^2 sr nm)"}
        coordv = {'acoef':("wave","z"), 'acoef1':("wave","z"), 'acoef2':("wave","z"), 
                  'acoef3':("wave","z"), 'acoef4':("wave","z"), 
                  'bcoef':("wave","z"), 'bcoef1':("wave","z"), 'bcoef2':("wave","z"), 
                  'bcoef3':("wave","z"), 'bcoef4':("wave","z"), 
                  'bbcoef':("wave","z"), 'bbcoef1':("wave","z"), 'bbcoef2':("wave","z"),
                  'bbcoef3':("wave","z"), 'bbcoef4':("wave","z"), 
                  'atten':("wave","z"), 'albedo':("wave","z"), 'Eou':("wave","depth"), 
                  'Eod':("wave","depth"), 'Eu':("wave","depth"), 'Ed':("wave","depth"), 'mubar_u':("wave","depth"), 
                  'mubar_d':("wave","depth"), 'mubar':("wave","depth"), 'R':("wave","depth"), 
                  'Kd':("wave","z"), 'Ku':("wave","z"), 'Ko':("wave","z"), 
                  'Knet':("wave","z"), 'KLu':("wave","z"), 
                  'Rad_Ma':("wave","phi","theta"), 'Rad_Mz':("wave","z","phi","theta"), 
                  'Rad_Pa':("wave","phi","theta"), 'Rad_Pz':("wave","z","phi","theta"), 
                  'Rad_0Ma':("wave","phi","theta"), 'Rad_0Pa':("wave","phi","theta"), 
                  'Rad_0Pz':("wave","theta","phi","z"),'Rad_0Pz':("wave","z","phi","theta"), 
                  'Rad_sky':("wave","phi","theta")}

        # Add coordinates to the temporary dictionary
        for key, value in structure_dict.items():
            name = key.split(" (")[0]
            desc = key.split(" (")[1].replace(")","")
            coord = {"dims":name, "data":value, "attrs":{"description":desc, "units":unitsc[name]}}
            _tmp[name] = coord


        # Create a new depth variable with in air (-1) depth
        value = np.insert(_tmp["z"]["data"],0,"-1")
        desc = _tmp["z"]["attrs"]["description"]+" (-1: in air)"
        _tmp["depth"]={"dims":"depth", "data":value, "attrs":{"description":desc, "units":unitsc["zeta"]}}


        # Create a temporary dictionary to save the xarray formated values with empty arrays
        wd_tmp = {}
        for key, val in wl_dict[next(iter(wl_dict))].items():
            name = key.split(" (")[0]
            desc = key.split(" (")[1].replace(")","")
            name = name+"".join([n for n in desc if n.isdigit()])
            wd_tmp[name] = {"data":np.zeros((len(wl), len(val))),
                            "dims":(), "attrs":{"description":desc, 
                                                "units":unitsv[name]}}

        # Fill dictionary arrays for each variable
        i = 0
        for _, val_wl in wl_dict.items():
            for key, val in val_wl.items():
                name = key.split(" (")[0]
                desc = key.split(" (")[1].replace(")","")
                name = name+"".join([n for n in desc if n.isdigit()])
                wd_tmp[name]["data"][i,:] = val
                wd_tmp[name]["dims"] = coordv[name]
            i+=1

        for k in range(len(wl)):
            # Reshape arrays according to the coordinates for the radiances
            # Change the zero values of (theta=0, phi=:) to the value of (theta=0, phi=0)
            # This is done for easier analysis as L(theta=0, phi=:) = L(theta=0)
            wd_tmp["Rad_Ma"]["data"] = wd_tmp["Rad_Ma"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            wd_tmp["Rad_Ma"]["data"][k,:,-1] = wd_tmp["Rad_Ma"]["data"][k,0,-1]

            wd_tmp["Rad_Pa"]["data"] = wd_tmp["Rad_Pa"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            wd_tmp["Rad_Pa"]["data"][k,:,-1] = wd_tmp["Rad_Pa"]["data"][k,0,-1]

            wd_tmp["Rad_0Ma"]["data"] = wd_tmp["Rad_0Ma"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            wd_tmp["Rad_0Ma"]["data"][k,:,-1] = wd_tmp["Rad_0Ma"]["data"][k,0,-1]

            wd_tmp["Rad_0Pa"]["data"] = wd_tmp["Rad_0Pa"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            wd_tmp["Rad_0Pa"]["data"][k,:,-1] = wd_tmp["Rad_0Pa"]["data"][k,0,-1]


            wd_tmp["Rad_sky"]["data"] = wd_tmp["Rad_sky"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            wd_tmp["Rad_sky"]["data"][k,:,-1] = wd_tmp["Rad_sky"]["data"][k,0,-1]

            wd_tmp["Rad_Mz"]["data"] = wd_tmp["Rad_Mz"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["z"]["data"]),
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            for i in range(len(_tmp["z"]["data"])):
                wd_tmp["Rad_Mz"]["data"][k,i,:,-1] = wd_tmp["Rad_Mz"]["data"][k,i,0,-1]

            wd_tmp["Rad_Pz"]["data"] = wd_tmp["Rad_Pz"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["z"]["data"]),
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            for i in range(len(_tmp["z"]["data"])):
                wd_tmp["Rad_Pz"]["data"][k,i,:,-1] = wd_tmp["Rad_Pz"]["data"][k,i,0,-1]

            wd_tmp["Rad_0Pz"]["data"] = wd_tmp["Rad_0Pz"]["data"].reshape((len(_tmp["wave"]["data"]), 
                                                                        len(_tmp["z"]["data"]),
                                                                        len(_tmp["phi"]["data"]), 
                                                                        len(_tmp["theta"]["data"])))
            for i in range(len(_tmp["z"]["data"])):
                wd_tmp["Rad_0Pz"]["data"][k,i,:,-1] = wd_tmp["Rad_0Pz"]["data"][k,i,0,-1]



        # Add the wavelength dependant variables to the temporaty dictionary
        _tmp.update(wd_tmp)

        # Create the xarray and set the title
        s = xr.Dataset.from_dict(_tmp)
        s.attrs["title"] = title_run

        # Compute radiances from matrices
        s = s.assign({"Lw_air":s.Rad_Ma}) 
        s["Lw_air"].attrs["description"] = "water leaving radiance in air"

        s = s.assign({"Lrefl_air":s.Rad_0Ma}) 
        s["Lrefl_air"].attrs["description"] = "reflected radiance in air"

        s = s.assign({"Lu_air":s.Rad_0Ma+s.Rad_Ma}) 
        s["Lu_air"].attrs["description"] = "upwards radiance in air"
        s["Lu_air"].attrs["units"] = "W/m^2 nm sr"

        s = s.assign({"Lsky_air":s.Rad_sky}) 
        s["Lsky_air"].attrs["description"] = "sky radiance in air"

        s = s.assign({"Lu_water":s.Rad_Mz}) 
        s["Lu_water"].attrs["description"] = "upwards radiance in water"

        s = s.assign({"Ld_water":s.Rad_Pz+s.Rad_0Pz}) 
        s["Ld_water"].attrs["description"] = "downwards radiance in water"
        s["Ld_water"].attrs["units"] = "W/m^2 nm sr"

        # Calculate apparent optical properties
        s["Rrs"] = s.Lw_air/s.Ed.sel(depth=-1)
        s["Rrs"].attrs["description"] = "Remote sensing reflectance"
        s["Rrs"].attrs["units"] = "1/sr"

        s["rho"] = (s.Lrefl_air/s.Lsky_air)
        s["rho"].attrs["description"] = "rho"
        s["rho"].attrs["units"] = ""

        s["f-over-Q"] = (s.Lu_water/(s.Ed*s.bbcoef/s.acoef))
        s["f-over-Q"].attrs["description"] = "f/Q"
        s["f-over-Q"].attrs["units"] = "1/sr"


        return s